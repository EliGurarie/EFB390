<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>.white[Counting Animals Part II: Sample Counts]</title>
    <meta charset="utf-8" />
    <meta name="author" content=".white[Dr. Elie Gurarie]" />
    <script src="Lecture06_CountingAnimals_PartII_files/header-attrs-2.21/header-attrs.js"></script>
    <link href="Lecture06_CountingAnimals_PartII_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="Lecture06_CountingAnimals_PartII_files/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="mycss.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: left, title-slide

.title[
# .white[Counting Animals Part II: Sample Counts]
]
.subtitle[
## .white[EFB 390: Wildlife Ecology and Management]
]
.author[
### .white[Dr. Elie Gurarie]
]
.date[
### .white[September 12, 2023]
]

---


&lt;!-- https://bookdown.org/yihui/rmarkdown/xaringan-format.html --&gt;







## Drawbacks of total counts / censusing

.pull-left-60.large[


Expensive &amp; labor-time intensive

Impractical for MOST species / systems
  - need to ALL be **visible**
  - the **ENTIRE** study area needs to be survey-able
  
Hard to assess precision

]

.pull-right-40[
![](images/hippos.png)

.center[**Hippos**]

.small.grey[(Marc Mol/Mercury Press/Caters)]
]

---

### Is the great Elephant Census a Census?

&lt;iframe src="https://www.youtube.com/embed/imvehfydUpc?controls=0" width="900px" height="500px"&gt;
&lt;/iframe&gt;

---

## Sample counts

### Simple idea: 
- count *some* of the individuals
- extrapolate!

### In practice:
- Involves some tricky statistics and modeling!
- Necessarily - less *precise* due to *sampling error*. 
- BUT ... if properly done ... more *accurate* and **much less effort**. 

---






## A random population

.pull-left-60[

![](images/Pop1.png)

]

--

.pull-right-40[

### Population density

.large[$$N = A \times D$$]
- `\(N\)` - total count
- `\(A\)` - total area
- `\(D\)` - overall density
]

---

## Sampling from the population


.pull-left-60[
![](images/Pop2.png)

**Squares**, aka, **quadrats**
]

--

.pull-right-40[

### *Sample* density:

`$$n_{sample} = \sum_{i=1}^k n_i$$`
`$$a_{sample} = \sum_{i=1} a_i$$`

`$$d_{sample} = {n_{sample} \over a_{sample}}$$`

]



---
### Sample vs. Population

 | Population | Sample
--|:--:|:--
size | `\(N\)` | `\(n_s\)`
area | `\(A\)` | `\(a_s\)`
density | `\(D\)` | `\(d_s\)`

Note: sample density is an *estimate* of total density.  So `\(\widehat{D} = d_s\)`.

--

True population: 

.green.large[$$N = A \times D$$]

Population **estimate** (best guess for `\(N\)`): just replace true (unknown) density `\(D\)` with *sampling estimate* of density `\(d_s\)`:

.red.large[$$\widehat{N} = A \times \widehat{D} = A \times d_s =  A \times {n_s \over a_s}$$]


---
## Example


.pull-left[
![](images/Pop2.png)
]

### Data
.blue[10 quadrats; 10x10 km each]

.blue[ `n = {0,0,5,0,3,1,2,3,6,1}`]

.red[**note:** *variability / randomness!*]

--


### Analysis

.green[
`\(n_s = \sum n_i = 21\)`

`\(d_s = \widehat{D} = {21 \over 10 \times 10 \times 10} = 0.021\)`

`\(A = 100 \times 100\)`
]

--


#### final estimate:

.large.green[
`$$\widehat{N} = \widehat{D} \times A = 100\times100\times0.021 = \textbf{210}$$`]


---
## What happens when we do this many times?



.pull-left[
![](images/popSims.png)
]





.pull-right[
Every time you do this, you get a different value for `\(\widehat{N}\)`. 

![](images/SimHist.png)

]


---

### Statistics

.pull-left[

**Mean of estimates:** 
`$$\widehat{N} = 301.5$$`

**S.D. of estimate:**
`$$s_{\widehat{N}} = 54.6$$`

.red[**important**: the *standard deviation* of an *estimate* = **standard error**, SE]


**95% Confidence Interval:**

`$$\widehat{N} \pm 1.96 \times SE = \{195-408\}$$`
.green[**note:** the 1.96 is the number of standard deviatinos that captures 95% of a Normal distribution.]
]


.pull-right[
![](images/SimHist2.png)
]

--


Conclusion: this estimate is **accurate** (unbiased), but not very **precise** (big confidence interval).


---
### General principle: The bigger the sample, the smaller the error. 


`1.` If `\(a_s \ll A\)`  (i.e. low sampling intensity)

`$$SE(\widehat{N}) = {A \over a} {\sqrt{\sum n_i} \over k}$$`
**remember:** 
- `\(n_s = \sum n_i\)` is the total **sample count**
- `\(k\)` is the total number of samples: `\(i =\{1,2,...,k\}\)` )

.center.red[
in our example: `\(SE = 100²/10^2 \times \sqrt{21}/10 = 54.8\)`
]

--


`2.` If you are NOT resampling previously sampled locations: 

`$$SE(\widehat{N}) = {A \over ak} \sqrt{\sum n_i \left(1 - {a_s \over A}\right)}$$`

This is the .blue[Finite Area Correction].  If `\(a = A\)` - you sampled everything - SE goes to 0 as expected.  

.center.red[
in our example: `\(SE = 54.5\)`
... Almost no difference (because `\(a \ll A\)`).
]



---
## Some more complex formulae


 from Fryxell book Chapter 12:

![](images/fryxellformulae.png)
These are used when **sampling areas** are unequal, and account for differences when sampling **with replacement** or **without replacement**. 




---
### Poisson process

Models *counts*.  If you have a perfectly random process with mean *density* (aka *intensity*) 1, you might have some 0 counts, you might have some higher counts.  The *average* will be 1:

![](images/Poisson1.png)



---
### Poisson process

Here, the intensity is 4 ...

![](images/Poisson4.png)


---
### Poisson process

... and 10.  Note, the bigger the intensity, the more "bell-shaped" the curve. 

![](images/Poisson10.png)

Here's the formula of the Poisson Distribution: `\(\!f(k; \lambda)= \Pr(X{=}k)= \frac{\lambda^k e^{-\lambda}}{k!}\)`


---
### Poisson distribution holds if process is truly random

... not **clustered** or **inhibited**

![](images/processes.png)
If you **sample** from these kinds of spatial distributions, your standard error might be smaller (*inhibited*) or larger (*clustering*).  This is called *dispersion*.  



---
### Also ... densities of animals depend on habitat!
.pull-left-60[
**Wolf habitat use**
![](images/vikihabitat.png)

]

.pull-right-40[
If you look closely: 

- No locations in lakes
- Relatively few in bogs / cultivated areas.
- Quite a few in mixed and coniferous forest

]

---
## Imagine a section of forest ...

.pull-left-60[
![](images/Moose1.png)]


---
## ... with observations of moose

.pull-left-60[
![](images/Moose2.png)]

.pull-right-40[
**How can we tell what the moose prefers?**


Habitat | Area | n | Density
---:|:---:|:---:|:---
open | 100 | 21 | 0.21
mixed | 100 | 43 | 0.43
dense | 200 | 31 | 0.16
**total** | 400 | 95 | 0.24

]




.blue[Knowing how densities differ as a function of **covariates** can be very important for generating estimates of abundances, increasing both **accuracy** and **precision**, and informing **survey design**.]


---
### Sample frames need not be **squares**

.pull-left-50[

![](images/aerial-survey.jpg)

]

.pull-right-50[

## Transects


Linear strip, usually from an aerial survey. 

Efficient way to sample a lot of territory. 

If "perfect detection", referred to as a **strip transect**. 

Statistics - essentially - identical to quadrat sampling. 


]

.footnote[https://media.hhmi.org/biointeractive/click/elephants/survey/survey-aerial-surveys-methods.html]


---
### **Stratified sampling** for more efficient estimation

![](images/stratification1.png)

Sample more intensely in those habitats where animals are more likely to be found. 
Intensely survey .orange[**blocks**] where detection is more difficult. 

.footnote[https://media.hhmi.org/biointeractive/click/elephants/survey/survey-aerial-surveys-methods.html]


---
### **Stratified sampling** for more efficient estimation

![](images/stratification2.png)

Actual elephant flight paths,

.footnote[https://media.hhmi.org/biointeractive/click/elephants/survey/survey-aerial-surveys-methods.html]


---
### **Stratified sampling** 

.pull-left[![](images/stratification1.png)]
.pull-right[![](images/stratification2.png)]

**Stratification** is used to optimize **effort** and **precision**.  Aircraft cost thousands of dollars per hour!

(In all of these comprehensize surveys - *design* takes care of **accuracy**). 


---
### Sampling strategies

.pull-left[![](images/samplingstrategies.png)]

.pull-right[
(a) simple random, 

(b) stratified random, 

(c) systematic, 

(d) pseudo-random (systematic unaligned).

Each has advantages and disadvantages.

See also: *Adaptive Sampling*
]

---
### Detections usually get *worse* with distance!

.pull-left-30[

![](images/DistanceEquations.png)

![](images/DistanceSampling.jpg)
]

.pull-right-70[

## Distance Sampling

The statistics of accounting for visibility decreasing with distance

![](images/DistanceCurves.webp)

]


---
## Example reindeer in Svalbard


![](images/DistanceReindeer.png)


.large[ **Estimated detection distance**, compared to **total count**, incorporated **vegetation modeling**, computed **standard errors**, concluded that you can get a 15% C.V. for 1/2 the cost.]

---
## Example Ice-Seals

![](images/lobodontini.png)

---
## Example: Flag Counting at Baker

![](images/court.png)

---

## Nice video on counting caribou

https://vimeo.com/471257951

![](images/countingcaribou.png)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"countIncrementalSlides": false,
"highlightLines": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
